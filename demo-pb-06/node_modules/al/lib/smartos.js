var exec = require('child_process').exec,
    fs = require('fs'),
    path = require('path'),
    httpget = require('http-get');

// commands = array of commands to run
module.exports.bash = function(opts, callback) {
  var cwd = opts.cwd || '/tmp',
      cmd = opts.cmd.join(' && '),
      run;
  // check for the existance of the file in the chef fashion
  if (opts.creates) {
    if (fs.existsSync(opts.creates)) {
      return callback();
    } // if
  } // if

  // check for the existance of the cwd, return err if not present
  if (!fs.existsSync(cwd)) {
    return callback(new Error('Chosen directory does not exist : ' + cwd));
  } // if

  run = exec(cmd, { cwd : cwd }, function(err, stdout, stderr) {
    if (err) {
      return callback(err);
    }
    callback();
  });
} // bash

// Source the name of a file contained within a flanno under files/
module.exports.flannoFile = function(source, dest, callback) {
  if (!(fs.existsSync(source))) {
    return callback(new Error('Flannofile not found'));
  } // if

  fs.writeFile(dest, fs.readFileSync(source), function(err) {
    callback(err);
  });
}

module.exports.pkg = function(packageName, callback) {
  var count = 0;

  function installed(packageName, callback) {
    // pkgin list, lists all installed packages on the system
    var run = exec('pkgin list | grep ' + packageName, function(err, stdout, stderr) {
      // if the package doesnt exist an error will be thrown
      // if its the first run through try and install it
      if (count === 0) {
        if (err) {
          install(packageName, callback);
        } else {
          callback();
        } // if...else
      } else {
        if (err) {
          // on the second time through and there is still an error, pass it to mocha
          callback(err);
        } else {
          // run should have succedded
          callback();
        } // if...else
      } // if...else
    });
  } // installed

  function install(packageName, callback) {
    var run = exec('pkgin -y install ' + packageName, function(err, stdout, stderr) {
      if (err) {
        return callback(err);
      }

      count++;
      installed(packageName, callback);
    }); 
  } // install
  // first run, check to see if the package exists
  installed(packageName, callback);
} // pkg

module.exports.remoteFile = function(url, filename, dest, callback) {
  var file = path.resolve(dest, filename)
  // check to see if the file already exists
  if (fs.existsSync(file)) {
    return callback();
  } // if

  httpget.get({ url : url }, file, function (err, result) {
    if (err) {
      return callback(err);
    }
    // check again to see if the file exists
    if (fs.existsSync(file)) {
      return callback();
    }
    // if not throw an error
    callback(new Error('File did not create'));
  });
} // remoteFile

// provides standard hooks to smartos services
module.exports.service = function(serviceName, action, manifest, callback) {
  var actions = {
    add : function(callback) {
      var run;

      if (typeof manifest == 'undefined') {
        return callback(new Error('Manifest file not specified'));
      }

      if (!(fs.existsSync(manifest))) {
        return callback(new Error('Manifest file does not exist'));
      } // if


      run = exec('svccfg import ' + manifest, function(err, stdout, stderr) {
        if (err) {
          return callback(err);
        } // if
        callback();
      });
    },
    enable : function(callback) {
      var run = exec('svcadm enable ' + serviceName, function(err, stdout, stderr) {
        if (err) {
          return callback(err);
        } // if
        callback();
      });
    },
    disable : function(callback) {
      var run = exec('svcadm disable ' + serviceName, function(err, stdout, stderr) {
        if (err) {
          return callback(err);
        } // if
        callback();
      });
    }, 
    restart : function(callback) {
      var run = exec('svcadm restart ' + serviceName, function(err, stdout, stderr) {
        if (err) {
          return callback(err);
        } // if
        callback();
      });
    }
  };

  if (actions[action]) {
    actions[action](callback);
  } // if
} // service
